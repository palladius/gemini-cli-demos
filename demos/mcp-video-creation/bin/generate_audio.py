#!/usr/bin/env python3
"""
generate_audio.py - Generate audio files from text using Google Cloud Chirp3 TTS via MCP

DESCRIPTION:
    This script generates audio files from text files using the mcp-chirp3-go MCP tool,
    which interfaces with Google Cloud's Chirp3 Text-to-Speech API.
    
    Note: This script was created for generating full-length audio but has limitations.
    The Chirp API has a timeout of ~30 seconds, making it unsuitable for very long texts.
    For long stories, use the chunking approach instead (see concatenate_audio.py).

PREREQUISITES:
    1. mcp-chirp3-go must be installed and in PATH (usually ~/go/bin/mcp-chirp3-go)
       Install from: https://github.com/GoogleCloudPlatform/vertex-ai-creative-studio/
    2. Google Cloud authentication must be configured
       Run: just auth (or bin/gcloud-auth)
    3. Python 3.x with standard libraries (json, subprocess, os, glob, sys, argparse)

USAGE:
    # Default mode (hardcoded files):
    python3 generate_audio.py
    
    # From a text file:
    python3 generate_audio.py story.txt [--voice VOICE_NAME] [--output OUTPUT.wav]
    
    # From stdin:
    echo "Hello world" | python3 generate_audio.py - [--voice VOICE_NAME] [--output OUTPUT.wav]
    cat story.txt | python3 generate_audio.py -

ARGUMENTS:
    input_file          Text file to convert (use "-" for stdin)
    --voice, -v         Voice name (default: en-US-Chirp3-HD-Fenrir)
    --output, -o        Output filename (default: auto-generated based on input)
    --output-dir, -d    Output directory (default: same as input file, or current dir for stdin)

EXAMPLES:
    python3 generate_audio.py story.txt
    python3 generate_audio.py story.txt --voice it-IT-Chirp3-HD-Zephyr --output italian.wav
    echo "Test" | python3 generate_audio.py - --output test.wav

KNOWN ISSUES:
    - Large text files (>3000 chars) will timeout
    - Solution: Split text into chunks and use concatenate_audio.py

AUTHOR:
    Generated by Gemini AI for the mcp-video-creation demo project
"""

import json
import subprocess
import os
import sys
import glob
import argparse

def generate_audio(text, output_dir, output_filename, voice_name):
    """
    Generate audio from text using mcp-chirp3-go.
    
    Args:
        text: The text to convert to speech
        output_dir: Directory where audio file will be saved
        output_filename: Name of the output file
        voice_name: Chirp3 voice name
    
    Returns:
        Path to generated file or None on failure
    """
    # Ensure output directory exists and clean up old temporary files
    os.makedirs(output_dir, exist_ok=True)
    
    # Remove any leftover chirp_audio-*.wav files to avoid confusion
    for old_file in glob.glob(os.path.join(output_dir, "chirp_audio-*.wav")):
        try:
            os.remove(old_file)
        except Exception:
            pass
    
    # Record timestamp before starting subprocess
    import time
    start_time = time.time()
    
    # Construct JSON payload
    payload = {
        "jsonrpc": "2.0",
        "method": "tools/call",
        "id": 1,
        "params": {
            "name": "chirp_tts",
            "arguments": {
                "voice_name": voice_name,
                "text": text,
                "output_directory": output_dir
            }
        }
    }

    json_payload = json.dumps(payload)
    
    # Call mcp-chirp3-go
    mcp_tool = os.path.expanduser("~/go/bin/mcp-chirp3-go")
    
    print(f"Generating audio using voice {voice_name}...")
    print(f"Text length: {len(text)} characters")
    
    try:
        process = subprocess.Popen(
            [mcp_tool],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = process.communicate(input=json_payload)
        
        if stderr:
            # Print stderr but don't fail - it might just be logs
            for line in stderr.splitlines():
                if "Error" in line or "error" in line:
                    print(f"STDERR: {line}", file=sys.stderr)
        
        if process.returncode != 0:
            print(f"Error generating audio: Return code {process.returncode}", file=sys.stderr)
            return None
        
        # Try to find the JSON in stdout
        for line in stdout.splitlines():
            try:
                response = json.loads(line)
                if "result" in response or "error" in response:
                    # Check for error
                    if "error" in response:
                        print(f"MCP Error: {response['error']}", file=sys.stderr)
                        return None
                    break
            except json.JSONDecodeError:
                continue
        
        # Find the generated file - look specifically for chirp_audio-*.wav files created after start_time
        candidate_files = glob.glob(os.path.join(output_dir, "chirp_audio-*.wav"))
        if not candidate_files:
            # Fallback to any .wav file if chirp naming wasn't used
            candidate_files = glob.glob(os.path.join(output_dir, "*.wav"))
        
        if not candidate_files:
            print("No audio file found generated.", file=sys.stderr)
            return None

        # Find the file created after we started the subprocess
        generated_path = None
        for f in sorted(candidate_files, key=os.path.getctime, reverse=True):
            if os.path.getctime(f) > start_time:
                generated_path = f
                break
        
        # Fallback to newest file if none are newer than start_time (shouldn't happen)
        if not generated_path:
            generated_path = max(candidate_files, key=os.path.getctime)
        
        print(f"Generated: {generated_path}")
        
        target_path = os.path.join(output_dir, output_filename)
        if generated_path != target_path:
            os.rename(generated_path, target_path)
            print(f"Renamed to: {target_path}")
        
        return target_path

    except FileNotFoundError:
        print(f"Tool {mcp_tool} not found. Please install mcp-chirp3-go.", file=sys.stderr)
        return None

def main():
    parser = argparse.ArgumentParser(
        description='Generate audio from text using Google Cloud Chirp3 TTS',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s story.txt
  %(prog)s story.txt --voice it-IT-Chirp3-HD-Zephyr --output italian.wav
  echo "Hello" | %(prog)s - --output hello.wav
        """
    )
    
    parser.add_argument('input_file', nargs='?', 
                        help='Text file to convert (use "-" for stdin, omit for default mode)')
    parser.add_argument('-v', '--voice', default='en-US-Chirp3-HD-Fenrir',
                        help='Voice name (default: en-US-Chirp3-HD-Fenrir). Use it-IT-Chirp3-HD-Zephyr for Italian.')
    parser.add_argument('-o', '--output',
                        help='Output filename (default: auto-generated)')
    parser.add_argument('-d', '--output-dir',
                        help='Output directory (default: same as input file)')
    
    args = parser.parse_args()
    
    # If no explicit input file is provided, but data is being piped in via stdin, treat it as stdin.
    if args.input_file is None and not sys.stdin.isatty():
        args.input_file = '-'

    # Default mode: process hardcoded files when no input is specified at all.
    if args.input_file is None:
        print("Running in default mode (hardcoded files)...")
        base_dir = "out/milan/demo01-alessandro-story"
        
        # English
        with open(f"{base_dir}/story-en.txt", 'r') as f:
            text_en = f.read()
        generate_audio(text_en, base_dir, "story-en.wav", "en-US-Chirp3-HD-Fenrir")
        
        # Italian
        with open(f"{base_dir}/story-it.txt", 'r') as f:
            text_it = f.read()
        generate_audio(text_it, base_dir, "story-it.wav", "it-IT-Chirp3-HD-Zephyr")
        
        return
    
    # Read input
    if args.input_file == '-':
        # Read from stdin
        text = sys.stdin.read()
        input_dir = args.output_dir or '.'
        default_output = 'output.wav'
    else:
        # Read from file
        if not os.path.exists(args.input_file):
            print(f"Error: File not found: {args.input_file}", file=sys.stderr)
            sys.exit(1)
        
        with open(args.input_file, 'r') as f:
            text = f.read()
        
        input_dir = args.output_dir or os.path.dirname(args.input_file) or '.'
        # Generate default output name from input
        base_name = os.path.splitext(os.path.basename(args.input_file))[0]
        default_output = f"{base_name}.wav"
    
    output_filename = args.output or default_output
    
    # Ensure output directory exists
    os.makedirs(input_dir, exist_ok=True)
    
    # Generate audio
    result = generate_audio(text, input_dir, output_filename, args.voice)
    
    if result:
        print(f"✅ Success! Audio saved to: {result}")
        sys.exit(0)
    else:
        print("❌ Failed to generate audio", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
